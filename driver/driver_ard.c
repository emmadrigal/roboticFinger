/*   Los mensajes se env√≠an acabados en '\n' en ambas direcciones.   Si no se ejecuta "sudo chmod 777 /dev/ttyUSB*" a veces no se puede usar serial desde PHP   Tomado de http://forum.arduino.cc/index.php?topic=65230.0 y https://csl.name/post/c-functions-python/*/#include <stdlib.h>#include <stdio.h>#include <string.h>#include <time.h>#include <fcntl.h>#include <errno.h>#include <termios.h>#include <signal.h>#include <unistd.h>#include <signal.h>#include <Python.h>char codigo_hacia_arduino[99];char codigo_desde_arduino[99];char dato[2];int fd;   /* File descriptor for the port */     int verbose;int open_port(void){   char ttyport[33];   int n;	   // intentar abrir ttyUSB0, ttyUSB1, ttyUSB2 ...   for(n=0;n< 10;n++)   {      sprintf(ttyport, "/dev/ttyUSB%d", n);         fd = open(ttyport, O_RDWR | O_NDELAY);      if (fd != -1)       {          break;      }   }   if (fd == -1)   {       printf("\nttyUSB port error!\n\n");       return fd;   }   else   {       struct termios options;      // Get the current options for the port...       tcgetattr(fd, &options);     // Set the baud rates to B9600...     cfsetispeed(&options, B9600);     // Enable the receiver and set local mode...     options.c_cflag |= (CLOCAL | CREAD);     // Set the new options for the port...     tcsetattr(fd, TCSANOW, &options);     options.c_cflag &= ~CSIZE;   /* Mask the character size bits */     options.c_cflag |= CS8;      /* Select 8 data bits */     options.c_cflag &= ~PARENB;     options.c_cflag &= ~CSTOPB;     options.c_cflag &= ~CSIZE;     options.c_cflag |= CS8;     //~ fcntl(fd, F_SETFL, 0);     return (fd);   }}enviar_hacia_arduino(){    write(fd, codigo_hacia_arduino, strlen(codigo_hacia_arduino));    waitFor(4);}int recibir_desde_arduino(){   int n;   n = 0;   strcpy(codigo_desde_arduino, "");   for(;;)   {       strcpy(dato, "");       read(fd,dato,1);       if(dato[0] ==  10)       {          codigo_desde_arduino[n] = '\0';          break;       }       else if(dato[0] == 13);       else if(dato[0] > 0 && n < 98)          codigo_desde_arduino[n++] = dato[0];   }   return strlen(codigo_desde_arduino);}int establecer_conexion() //retorna -1 en caso de que no sea posible{	verbose = 1;    	fd = 0;    	fd = open_port();	waitFor(3);    	return fd;}void enviarMensaje(char *mensaje){	strncpy(codigo_hacia_arduino, mensaje, 99);	if(codigo_hacia_arduino[strlen(codigo_hacia_arduino) - 1] != '\n')	   strcat(codigo_hacia_arduino, "\n");	enviar_hacia_arduino();	waitFor(1);}char* enviar_recibir_msj(char *mensaje){	strncpy(codigo_hacia_arduino, mensaje, 99);	if(codigo_hacia_arduino[strlen(codigo_hacia_arduino) - 1] != '\n')	   strcat(codigo_hacia_arduino, "\n");	enviar_hacia_arduino();	if(recibir_desde_arduino())  	    return codigo_desde_arduino;}void waitFor (unsigned int secs) {    unsigned int retTime = time(0) + secs;   // Get finishing time.    while (time(0) < retTime);               // Loop until it arrives.}static PyObject* conexion_ard(PyObject *self, PyObject *args){    int out=0;    if (establecer_conexion() == -1)out= -1;    return Py_BuildValue("d", out);}static PyObject* enviar_msj(PyObject *self, PyObject *args){    char *mensaje;    PyArg_ParseTuple(args, "s", &mensaje);    enviarMensaje(mensaje);    return Py_BuildValue("d", 1);}static PyMethodDef ardDriver_methods[] = {  {"conexion_ard", conexion_ard, METH_VARARGS},  {"enviar_msj", enviar_msj, METH_VARARGS},  {NULL, NULL}};void initardDriver(){  (void) Py_InitModule("ardDriver", ardDriver_methods);}/*main(){     if (establecer_conexion() == -1)exit(0);    enviarMensaje("AF2");    enviarMensaje("AF3");    enviarMensaje("AF5");    enviarMensaje("AF2");    enviarMensaje("AF4");    enviarMensaje("AF6");    enviarMensaje("AF7");    enviarMensaje("AF1");}*/